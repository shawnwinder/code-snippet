#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;


/**
 * Classical "0-1 Knapsack" problem
 *
 * N items, weight of each item is w_i, value of each item is v_i.
 * A knapsack with capacity M.
 * Say, the maximum value the knapsack can hold with the total weight of items no exceeding M?
**/
// these two functions below can be merged togather
// full dp
int knapsack_value(vector<int>& weight, vector<int>& value, int M) {
    // initialization
    int N = weight.size();
    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));
    
    // dp
    for (int i = 1; i <= N; ++ i) {
        for (int j = 1; j <= M; ++ j) {
            dp[i][j] = dp[i - 1][j]; // important
            if (j >= weight[i - 1]) {   // Note: i-th item with the index of i - 1
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
            }
        }
    }

    return dp[N][M];
}

// knapsack with space compression
// Note: this way cannot recover the path (solution sequence)
int knapsack_value2(vector<int>& weight, vector<int>& value, int M) {
    int N = weight.size();
    vector<int> dp(M + 1, 0);
    for (int i = 1; i <= N; ++ i) {
        // reverse ordering ensures that when updating dp[p], dp[p - value[i - 1]]
        // stores the value of unchanged dp[p - value[i - 1]]
        for (int j = M; j >= 0; -- j) {
            if (j >= weight[i - 1]) {
                dp[j] = max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
            }
        }
    }

    return dp[M];
}

// Now, another question comes:
// Say, "What if multiply 1000 by each item's weight, value and knapsack's capacity?"
// knapsack with space compression 2, using "sequenced double(序偶）"
int knapsack_value3(vector<int>& weight, vector<int>& value, int M) {
    int N = weight.size();
    vector<int> V;
    vector<int> W;
    vector<int> pos(N + 1, 0);

    // init
    pos[1] = 1;
    V.push_back(0), W.push_back(0);
    int beg = 0, end = 0;
    int cur = 0;  // record S_{i-1} position
    int next = 1;  // record S_{i} position

    // merge S_{i-1} & S_{i} at the same time!
    // actually, store S_{i} with another space and then merge with S_{i-1} is simpler for coding
    for (int i = 1; i <= N; ++ i) {
        // first part, the sequnced double  <V, W> of S_{i} generate by S_{i - 1} may "<=" S_{i - 1}
        // the W generated by S_{i-1} is ensured to be <= M!
        int cur = beg;
        int real_end = beg;
        while (real_end <= end) {
            if (W[real_end] + weight[i - 1] <= M) {
                ++ real_end;
            }else {
                break;
            }
        }

        for (int j = beg; j < real_end; ++ j) {
            int v_next = V[j] + value[i - 1];
            int w_next = W[j] + weight[i - 1];
            while (cur <= end && W[cur] < w_next) {
                V.push_back(V[cur]), W.push_back(W[cur]);
                ++ next;
                ++ cur;
            }
            if (cur <= end && W[cur] == w_next) {
               v_next = max(v_next, V[cur]);
            }

            // at this point, W.back() <= w_next
            if (v_next > V.back()) {
                V.push_back(v_next), W.push_back(w_next);
                ++ next;
            }
            
            // pass those S_{i} <= S_{i - 1} 
            while (cur <= end && V[cur] <= V.back()) {
                ++ cur;
            }
        }

        // second part, the double sequnce <V, W> of S_{i} generate by S_{i - 1} is too big
        // maybe the W generated by S_{i - 1} > M!
        while (cur <= end) {
            V.push_back(V[cur]), W.push_back(W[cur]);
            ++ cur;
            ++ next;
        }

        // for loop
        beg = end + 1;
        end = next - 1;
        pos[i + 1] = next;
    }

    return V.back();
}


// ========================================================================
// ========================================================================
// ========================================================================


vector<int> knapsack_solution(vector<int>& weight, vector<int>& value, int M) {
    // initialization
    int N = weight.size();
    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));
    vector<int> solution(N, 0);
    
    // dp
    for (int i = 1; i <= N; ++ i) {
        for (int j = 1; j <= M; ++ j) {
            dp[i][j] = dp[i - 1][j]; // important
            if (j >= weight[i - 1]) {   // Note: i-th item with the index of i - 1
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
            }
        }
    }

    // get solution sequence
    int i = N;
    int v = M;
    while (i >= 1) {
        if (dp[i][v] == dp[i - 1][v]) {
            solution[i - 1] = 0;
        }else {
            solution[i - 1] = 1;
            v -= weight[i - 1];
        }
        -- i;
    }

    return solution;
}

vector<int> knapsack_solution2(vector<int>& weight, vector<int>& value, int M) { 
    int N = weight.size();
    vector<int> V;
    vector<int> W;
    vector<int> pos(N + 1, 0);

    // init
    pos[1] = 1;
    V.push_back(0), W.push_back(0);
    int beg = 0, end = 0;
    int cur = 0;  // record S_{i-1} position
    int next = 1;  // record S_{i} position

    // merge S_{i-1} & S_{i} at the same time!
    // actually, store S_{i} with another space and then merge with S_{i-1} is simpler for coding
    for (int i = 1; i <= N; ++ i) {
        // first part, the sequnced double  <V, W> of S_{i} generate by S_{i - 1} may "<=" S_{i - 1}
        // the W generated by S_{i-1} is ensured to be <= M!
        int cur = beg;
        int real_end = beg;
        while (real_end <= end) {
            if (W[real_end] + weight[i - 1] <= M) {
                ++ real_end;
            }else {
                break;
            }
        }

        for (int j = beg; j < real_end; ++ j) {
            int v_next = V[j] + value[i - 1];
            int w_next = W[j] + weight[i - 1];
            while (cur <= end && W[cur] < w_next) {
                V.push_back(V[cur]), W.push_back(W[cur]);
                ++ next;
                ++ cur;
            }
            if (cur <= end && W[cur] == w_next) {
               v_next = max(v_next, V[cur]);
            }

            // at this point, W.back() <= w_next
            if (v_next > V.back()) {
                V.push_back(v_next), W.push_back(w_next);
                ++ next;
            }
            
            // pass those S_{i} <= S_{i - 1} 
            while (cur <= end && V[cur] <= V.back()) {
                ++ cur;
            }
        }

        // second part, the double sequnce <V, W> of S_{i} generate by S_{i - 1} is too big
        // maybe the W generated by S_{i - 1} > M!
        while (cur <= end) {
            V.push_back(V[cur]), W.push_back(W[cur]);
            ++ cur;
            ++ next;
        }

        // for loop
        beg = end + 1;
        end = next - 1;
        pos[i + 1] = next;
    }

    // get solution sequence
    vector<int> solution(N + 1, 0);
    int v = V.back();
    int i = N;
    while (i >= 1) {
        int last = pos[i] - 1;
        if (v <= V[last]) {   // "<=" important
            solution[i] = 0;
        }else {
            solution[i] = 1;
            v -= value[i - 1];
        }
        -- i;
    }

    return solution;
}


int main() {
    // case 1
    vector<int> weight = {5, 6, 5, 1, 19, 7};  // weight of each item
    vector<int> value = {2, 3, 1, 4, 6, 5};  // value of each item
    int M = 10;  // capacity of the knapsack

    // case 2
    // vector<int> weight = {1, 2, 5, 6, 7};
    // vector<int> value = {1, 6, 18, 22, 28};
    // int M = 11; 

    // int res_v = knapsack_value(weight, value, M);
    // int res_v = knapsack_value2(weight, value, M);
    int res_v = knapsack_value3(weight, value, M);
    cout << "maximum knapsack value is: " << res_v << endl;;

    // vector<int> res = knapsack_solution(weight, value, M);
    vector<int> res = knapsack_solution2(weight, value, M);
    cout << "maximum knapsack value solution is: ";
    for (auto &n : res) cout << n << ",";
    cout << endl;

    return 0;
}
